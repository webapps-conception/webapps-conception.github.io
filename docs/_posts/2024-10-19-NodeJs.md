layout: post
title: "D√©velopper un Back End en Node.js"
date: 2024-10-19 02:00:00 +0002
tags: node

# D√©velopper en Node.js
## Cr√©er un serveur HTTP avec Node.js¬†: guide du d√©butant

üìù Dans ce post, nous allons reprendre les bases de la documentation [Create an HTTP Server with Node.js: Beginner's Guide](https://www.knowledgehut.com/blog/web-development/node-http-server "Create an HTTP Server with Node.js: Beginner's Guide"){:target="_blank"} traduite en fran√ßais afin de pouvoir installer notre environnement de d√©veloppement dans des conditions optimales, de mani√®re √† compendre les rouages du module `Node.js`.

Node.js est un puissant environnement d'ex√©cution JavaScript open source, multiplateforme et back-end qui s'ex√©cute sur le moteur V8 de Chrome et ex√©cute le code JavaScript en dehors d'un navigateur Web. Node.js permet aux d√©veloppeurs d'utiliser JavaScript pour √©crire des outils de ligne de commande ainsi que pour des scripts c√¥t√© serveur, ce qui signifie ex√©cuter des scripts c√¥t√© serveur pour produire un contenu de page Web dynamique avant que la page ne soit envoy√©e au navigateur Web de l'utilisateur. Par cons√©quent, Node.js repr√©sente un paradigme appel√© ¬´¬†JavaScript partout¬†¬ª qui, simplement mis en place, repr√©sente un d√©veloppement Web complet unifi√© autour d'un langage de programmation commun, plut√¥t que l'utilisation de langages diff√©rents pour les scripts c√¥t√© serveur et c√¥t√© client. 

L'application la plus basique pour essayer la m√™me chose est la mise en ≈ìuvre d'un serveur Web HTTP (HyperText Transfer Protocol). HTTP est un protocole utilis√© pour r√©cup√©rer des ressources telles que des documents HTML et plus encore. Il s'agit de la base la plus courante pour tout √©change de donn√©es sur le Web. Il s'agit essentiellement d'un protocole client-serveur, ce qui signifie que les requ√™tes sont d√©clench√©es par le destinataire, g√©n√©ralement le navigateur Web. Lorsque nous voyons une page dans notre navigateur, nous faisons en arri√®re-plan une requ√™te √† un autre syst√®me sur Internet, qui nous fournit la page Web en r√©ponse. Le syst√®me avec lequel nous communiquons via Internet est un serveur Web.

Dans cet article, nous couvrirons une impl√©mentation de base d'un simple serveur HTTP utilisant NodeJS. Un serveur http Node est le moyen le plus simple de mettre la main dessus et de pratiquer un serveur Web Node js.

>üí° Le code source de cet exercice est disponible sur le d√©p√¥t Github [webapps-conception/nodejs-server-example](https://github.com/webapps-conception/nodejs-server-example){:target="_blank"}.


#### Cr√©ation d'un serveur HTTP

Pour cet exemple, nous supposerons que Node.js est install√© sur le syst√®me. Node.js prend en charge la cr√©ation de serveurs Web pr√™ts √† l'emploi, ce qui signifie qu'un serveur Web Node js peut √™tre directement cr√©√© √† partir d'un jeu de commandes de base. 

Nous allons commencer par cr√©er un serveur http simple Node, dont le but sera de renvoyer un texte brut √† l'utilisateur. Cela couvrira les concepts cl√©s n√©cessaires √† la configuration d'un serveur, qui peuvent √† leur tour √™tre extrapol√©s pour fournir la base n√©cessaire pour renvoyer d'autres formats de donn√©es complexes tels que JSON. 

Tout d‚Äôabord, il est n√©cessaire de configurer un environnement, donc pour cela nous allons cr√©er un dossier appel√© sampleServer et cr√©er un fichier qui va h√©berger le serveur. Apr√®s cela, nous devons ouvrir le fichier dans un √©diteur de notre choix, puis commencer par charger le module http. Ceci est fourni en standard avec toutes les installations [Node.js](https://nodejs.org/fr){:target="_blank"}.

``` js
const http = require("http");
```

Le module http disponible avec le bundle Node js contient les fonctions n√©cessaires √† la cr√©ation du serveur, que nous d√©couvrirons plus tard. L'√©tape suivante consiste √† d√©finir deux constantes, l'h√¥te et le port. Cela ferait r√©f√©rence √† l'endroit o√π notre serveur sera li√©¬†:

``` js
const host = 'localhost'; 
const port = 8000; 
```

Comme mentionn√© pr√©c√©demment, un serveur Web accepte les requ√™tes de diff√©rents navigateurs et d'autres types de clients. Nous pouvons interagir avec un serveur Web via un nom de domaine, qui est ensuite traduit en adresse IP d'un syst√®me respectif par un serveur DNS. Une adresse IP est une s√©quence d'identifiants uniques de chiffres qui identifient un syst√®me sur un r√©seau. 

`Localhost` est une adresse priv√©e sp√©ciale que les syst√®mes informatiques utilisent pour se r√©f√©rer √† eux-m√™mes. Elle est g√©n√©ralement repr√©sent√©e par l‚Äôadresse IP interne 127.0.0.1 et n‚Äôest disponible que pour l‚Äôordinateur sp√©cifique, et non pour aucun des r√©seaux auxquels nous sommes connect√©s. 

Le `port` est un num√©ro utilis√© par les serveurs comme point de terminaison de nos adresses IP. Dans cet exemple, nous allons continuer avec le port 8000 pour notre serveur Web. Les ports 8080 et 8000 sont g√©n√©ralement utilis√©s comme ports par d√©faut dans les phases de d√©veloppement et de test, et il est en quelque sorte non-dit parmi les d√©veloppeurs de les utiliser plut√¥t que d'autres ports disponibles pour les serveurs HTTP. 

Lorsque nous lions notre serveur √† cet h√¥te et √† ce port sp√©cifiques, nous pouvons acc√©der √† notre serveur en visitant <http://localhost:8000> dans un navigateur local. Maintenant, afin de v√©rifier que le serveur est cr√©√©, nous devons ajouter une fonction qui, dans Node.js, est appel√©e en tant qu'√©couteur de requ√™tes. Cette fonction g√®re une requ√™te HTTP entrante et renvoie une r√©ponse HTTP respective. Cette fonction a deux arguments sp√©cifiques, un objet requ√™te et un objet r√©ponse. L'objet de requ√™te est charg√© de capturer toutes les donn√©es de la requ√™te HTTP entrante. L'objet de r√©ponse est charg√© de renvoyer les r√©ponses HTTP du serveur. 

Nous renverrons un message `Bonjour du serveur !`, chaque fois que quelqu'un y acc√©dera. Ajoutons ensuite cette fonction requise¬†:

``` js
const requestListener = function (req, res) { 
 res.writeHead(200); 
 res.end("Hello from Server!"); 
};
```

La fonction doit g√©n√©ralement √™tre nomm√©e en fonction de son objectif. Puisqu'il s'agit d'un exemple de cas g√©n√©rique, nous utiliserons le nom g√©n√©rique `requestListener`. 

Ces fonctions d'√©coute de requ√™te acceptent deux arguments sp√©cifiques, √† savoir la requ√™te et la r√©ponse. Dans l'exemple ci-dessus, ils sont √©crits sous la forme req et res, nous pouvons les nommer selon notre convenance. Un objet Request encapsule la requ√™te HTTP envoy√©e par l'utilisateur, qui est le premier argument. La r√©ponse HTTP renvoy√©e √† l'utilisateur est g√©n√©r√©e en interagissant avec l'objet Response qui est le deuxi√®me argument. Veuillez noter que si `requestListener()` n'utilise pas l'objet req, il doit n√©anmoins s'agir du premier argument de la fonction.

La premi√®re ligne, `res.writeHead(200)`, d√©finit le code d'√©tat HTTP n√©cessaire de la r√©ponse. Le code d'√©tat HTTP indique comment une requ√™te HTTP sp√©cifique a √©t√© trait√©e par le serveur. Il existe de nombreuses r√©ponses comme 404 repr√©sentant non trouv√©, 501 repr√©sentant un √©chec, etc. Dans ce cas, la valeur du code d'√©tat 200 correspond au succ√®s. 

La ligne suivante, `res.end("Hello from Server!")`, √©crit la r√©ponse en texte brut au client. Cette fonction est charg√©e de renvoyer toutes les donn√©es que le serveur doit renvoyer. Dans notre cas, il renvoie des donn√©es en texte brut. 

Enfin, nous pouvons maintenant cr√©er notre serveur et utiliser notre √©couteur de requ√™tes¬†: 

La ligne suivante de la fonction correspondante, `res.end("Hello from Server!")` est charg√©e de r√©√©crire la r√©ponse HTTP au client qui l'a demand√©e. Cette fonction g√®re tous les retours de donn√©es fournis par le serveur. Dans notre exemple, il renvoie des donn√©es textuelles. 

Enfin, nous pouvons maintenant cr√©er notre serveur en utilisant notre √©couteur de requ√™tes¬†:

``` js
const server = http.createServer(requestListener); 
server.listen(port, host, () => { 
 console.log(`Server is running on http://${host}:${port}`); 
});
```

Dans cet exemple, dans la premi√®re ligne, nous cr√©ons un nouvel objet serveur √† l'aide du module http, en utilisant la fonction `createServer()`. Cela montre que le serveur accepte les requ√™tes HTTP et les transmet √† la fonction `requestListener()`. 

Une fois le serveur cr√©√©, nous devons le lier √† une adresse r√©seau sp√©cifique. Cela se fait √† l‚Äôaide de la m√©thode `server.listen()`. Il accepte trois param√®tres¬†: le port, l'h√¥te et une fonction de rappel qui se d√©clenche lorsque le serveur commence √† √©couter. 

Notez que tous les arguments mentionn√©s sont en fait facultatifs, mais il est recommand√© d'indiquer explicitement le port et l'h√¥te que nous utilisons pour le serveur Web, car cela aide √† configurer l'√©quilibrage de charge ou un alias DNS, si n√©cessaire. La fonction de rappel enregistre √©galement un message sur la console afin que nous puissions savoir quand le serveur a commenc√© √† √©couter les connexions. 

Maintenant, pour tester cela, nous devons ex√©cuter le fichier js que nous avons cr√©√©¬†:

Node `sample.js` et on voit √ßa dans la console :

![nodejs-1.webp](/assets/images/nodejs-1.webp)

Apr√®s avoir ex√©cut√© cela, le serveur Node.js continuera √† fonctionner. Il ne s'arr√™tera que si nous terminons manuellement le processus qui ex√©cute le serveur ou s'il rencontre une erreur d'ex√©cution. 

Nous pouvons d√©sormais communiquer avec le serveur √† l'aide d'une fen√™tre de terminal distincte, en utilisant cURL, un outil CLI utilis√© pour transf√©rer des donn√©es vers et depuis un r√©seau. Nous pouvons directement utiliser curl sur l'adresse localhost et obtenir le r√©sultat.

![nodejs-2.webp](/assets/images/nodejs-2.webp)

Le d√©roulement du processus est le suivant¬†:

- Nous envoyons une requ√™te GET au serveur √† l'adresse http://localhost:8000 en utilisant Curl.
- Le serveur Node.js √©coute les connexions √† partir de l'adresse du serveur localhost. 
- Le serveur a ensuite transmis cette requ√™te √† la fonction requestListener(). 
- La fonction a renvoy√© les donn√©es texte ajout√©es avec le code d'√©tat 200, ce qui implique OK.
- Le serveur a ensuite renvoy√© cette r√©ponse √† cURL, qui est ensuite affich√©e dans le terminal.


#### Retour de contenu

La r√©ponse du serveur n'est pas toujours du texte brut, nous pouvons √©galement renvoyer du HTML, Json, XML, CSV et d'autres formats de r√©ponse. Nous pouvons √©galement renvoyer des donn√©es non textuelles telles que PDF, audio vid√©o, etc. 

Tout d'abord, pour garantir cela, nous devons d√©finir l'en-t√™te Content-Type dans nos r√©ponses HTTP avec le type de r√©ponse appropri√© et nous assurer que res.end() doit obtenir les donn√©es dans le bon format. 

Dans l'exemple suivant, nous verrons comment renvoyer des donn√©es json depuis le serveur. JSON signifie JavaScript Object Notation, qui est un format d'√©change de donn√©es bas√© sur du texte. Bien qu'il soit d√©riv√© de JavaScript, il est tr√®s ind√©pendant du langage, ce qui lui permet d'√™tre utilis√© par n'importe quel langage capable de l'analyser. JSON est le plus souvent utilis√© comme moyen incontournable pour accepter et renvoyer des donn√©es avec des API, en raison de sa taille de transfert de donn√©es inf√©rieure √† celle des normes d'√©change de donn√©es existantes. 

Cr√©ons un nouveau fichier avec le mod√®le pour le serveur :

``` js
const http = require("http"); 
const host = 'localhost'; 
const port = 8000; 
const requestListener = function (req, res) {}; 
const server = http.createServer(requestListener); 
server.listen(port, host, () => { 
 console.log(`Server is running on http://${host}:${port}`); 
});
```

Ici, nous renvoyons une r√©ponse JSON, nous allons donc modifier la fonction requestListener() pour renvoyer l'en-t√™te appropri√©¬†:

``` js
const requestListener = function (req, res) { 
 res.setHeader("Content-Type", "application/json"); 
};
```

La m√©thode `setHeader()` de l'objet de r√©ponse ajoute un en-t√™te HTTP √† la r√©ponse. Les en-t√™tes HTTP d√©duisent des informations suppl√©mentaires qui peuvent √™tre jointes √† la fois √† la demande ou √† la r√©ponse. La m√©thode `res.setHeader()` a besoin de deux arguments, le nom de l'en-t√™te et sa valeur correspondante. 

L'en-t√™te ¬´ Content-Type ¬ª est utilis√© pour indiquer le format des donn√©es transmises avec la demande ou la r√©ponse. Puisque nous allons utiliser JSON, notre Content-Type est application/json. 

Maintenant, afin de renvoyer un exemple de contenu JSON √† l'utilisateur, nous devrons modifier le fichier avec des informations JSON al√©atoires¬†:

``` js
const requestListener = function (req, res) { 
 res.setHeader("Content-Type", "application/json"); 
 res.writeHead(200); 
 res.end(`{"sample message": "This is a sample JSON response"}`); 
};
```

Ici √©galement, nous informons l'utilisateur que la requ√™te a abouti en renvoyant le code d'√©tat 200. Notez que dans l'appel `response.end()`, notre argument de cha√Æne contient un JSON valide. Voici le r√©sultat.

![nodejs-3.webp](/assets/images/nodejs-3.webp)


#### Servir une page HTML √† partir d'un fichier

HTML (HyperText Markup Language) est le format le plus couramment utilis√© pour permettre √† l'utilisateur d'interagir avec un serveur Web, √† l'aide d'un navigateur Web. Il a √©t√© cr√©√© sp√©cifiquement pour le contenu Web structur√©. Tous les navigateurs Web prennent en charge le contenu HTML, ainsi que tout ajout de style effectu√© avec CSS. CSS est un autre √©l√©ment de technologie Web frontal qui nous permet de modifier l‚Äôesth√©tique globale de nos sites Web. 

Afin de renvoyer la page html, nous devons sp√©cifier le type de contenu dans l'objet de r√©ponse similaire √† ce que nous avions fait dans le cas de JSON dans l'exemple pr√©c√©dent.

``` js
const requestListener = function (req, res) { 
 res.setHeader("Content-Type", "text/html"); 
 res.writeHead(200); 
 res.end(`<html><body><h2><Strong>This is HTML</h2></body></html>`); 
};
```

Une fois que nous avons ex√©cut√© ce fichier JavaScript et ouvert <http://localhost:8000> dans un navigateur, nous pouvons voir le code HTML que nous avons renvoy√©.

![nodejs-4.webp](/assets/images/nodejs-4.webp)

Cependant, outre l'ajout manuel du contenu, nous pouvons √©galement servir une page HTML √† partir d'un fichier comme r√©ponse. Pour servir des fichiers HTML, nous chargeons le fichier HTML √† l'aide du ¬´ module fs ¬ª et utilisons ses donn√©es lors de l'√©criture de notre r√©ponse HTTP. 

Prenons l'exemple d'un exemple de page html que nous devons afficher :

``` html
<!DOCTYPE html> 
<html> 
<body> 
  <H1> This is an Html from a file </H1> 
  <p> This is the common ways to serve a page</p> 
</body> 
</html>
```

Maintenant, pour importer le fichier, nous devons d'abord le lire, ce qui se fait √† l'aide du module fs :

``` js
const http = require("http"); 
const fs = require('fs').promises;
```

Le module fs contient une fonction `readFile()` qui est g√©n√©ralement utilis√©e pour charger des fichiers HTML. Afin de suivre les pratiques JavaScript modernes, nous importons la variante promise de l'appel. C'est √©galement mieux que les rappels, dans divers cas. 

Nous devons maintenant modifier le fichier js en cours d'ex√©cution avec ces informations et renvoyer la page en utilisant then une fois termin√© :

``` js
const requestListener = function (req, res) { 
 fs.readFile(__dirname + "/samplePage.html") 
 .then(contents => { 
 res.setHeader("Content-Type", "text/html"); 
 res.writeHead(200); 
 res.end(contents); 
 }) 
.catch(err => { 
 res.writeHead(500); 
 res.end(err); 
 return; 
 }); 
};
```

Ici, la m√©thode `fs.readFile()` est utilis√©e pour charger le fichier. Il a 2 arguments `__dirname` et `/samplePage.html`. La variable `__dirname` repr√©sente ici le chemin absolu, o√π le code Node.js est actuellement en cours d'ex√©cution. Nous pouvons ensuite ajouter `/samplePage.html` √† ce chemin afin de pouvoir charger le fichier HTML que nous souhaitons servir. 

Une fois la promesse `fs.readFile()` r√©solue avec succ√®s, elle renverra les donn√©es correspondantes. Nous utilisons ensuite la m√©thode `then()` pour g√©rer ce cas de suivi. Le param√®tre contents est celui qui contient les donn√©es r√©elles du fichier HTML. 

Il est conseill√© d'utiliser la m√©thode `catch()` en association avec une promesse, car lorsqu'une promesse rencontre une erreur, elle est rejet√©e, il est donc pr√©f√©rable de g√©rer √©galement ces cas. Le bloc `catch` accepte l'erreur renvoy√©e par `fs.readFile()` et d√©finit le code d'√©tat sur 500, ce qui indique une erreur interne du serveur et le renvoie √† l'utilisateur. 

Nous pouvons voir le r√©sultat une fois que nous ex√©cutons le fichier¬†:

![nodejs-5.webp](/assets/images/nodejs-5.webp)


#### Gestion des routes par objet de requ√™te HTTP

La plupart des sites Web ou des API que nous visitons ou utilisons ont g√©n√©ralement plusieurs points de terminaison d'URL afin que nous puissions acc√©der √† diverses ressources disponibles dans le m√™me. Un exemple courant serait un cas de gestion des stocks, qui pourrait √™tre utilis√© dans un entrep√¥t. Il aurait non seulement besoin de g√©rer les donn√©es d'inventaire, mais il g√©rerait √©galement la quantit√©, le nom du fabricant, etc., quelles que soient les donn√©es n√©cessaires aux processus de catalogage et de recherche pour plus de commodit√©. 

M√™me si les donn√©es json ici, le nom de l'article et le nom du fabricant sont li√©s en termes d'inventaire qu'ils repr√©sentent, ce sont des objets diff√©rents. Dans ces cas, les informations de r√©ponse de chaque objet sont g√©n√©ralement stock√©es sur diff√©rents points de terminaison. Cela permet d‚Äôindiquer facilement √† l‚Äôutilisateur actuel de l‚ÄôAPI avec quel type de donn√©es il interagit. 

Jusqu'√† pr√©sent, nous n'avons construit aucune logique de routage sp√©ciale dans la fonction requestListener() pour g√©rer les requ√™tes dont l'URL contient d'autres chemins, donc si nous appelons <http://localhost:8000/random>, Node.js renverra la m√™me r√©ponse que celle-ci. de <http://localhost:8000> qui est celui par d√©faut. 

Dans l'exemple suivant, nous allons cr√©er un nouveau serveur pour un petit syst√®me d'inventaire, qui peut renvoyer 2 types de donn√©es diff√©rents. Le point de terminaison de l‚Äôadresse du serveur √† `/items` fournira une liste d‚Äô√©l√©ments avec leurs quantit√©s respectives en JSON. Le point final `/manufacturers` fournira une liste d‚Äôinformations sur les fabricants au format JSON. Commen√ßons par stocker nos donn√©es JSON dans des variables avant la fonction `requestListener()`¬†:

``` js
const items = JSON.stringify([ 
 { itemName: "Measuring Tape", manufacturer: "3M", quantity: 52 }, 
 { itemName: "DrillBit", manufacturer: "Bosch", quantity: 47 } 
]); 
const manufacturers = JSON.stringify([ 
 { name: "3M", countryOfOrigin: "America", partnerSince: 2019 }, 
 { name: "Bosch", countryOfOrigin: "Germany", partnerSince: 2014 } 
]);
```

La variable `items` est une cha√Æne qui contient du JSON pour un tableau d'objets item. Chaque article a un nom, le nom d‚Äôun fabricant et les quantit√©s respectives. La variable Manufacturers est une cha√Æne qui contient le JSON d'un tableau d'objets Manufacturer. Chaque fabricant a un nom, un pays d'origine, et depuis quand ils sont partenaires. 

Maintenant que nous avons ajout√© les donn√©es aux r√©ponses, nous les obtiendrons en retour. Donc pour cela, nous devons modifier la fonction `requestListener()` pour acheminer les requ√™tes vers les routes correctes, mais nous devons d'abord nous assurer que chaque r√©ponse du serveur a le bon en-t√™te Content-Type respectif, dans notre cas, il s'agit de JSON. Apr√®s cela, nous devons renvoyer le bon JSON en fonction du chemin URL visit√© par l'utilisateur. Afin d'obtenir un chemin URL √† partir de l'objet de requ√™te, nous devons acc√©der √† la propri√©t√© `url`. Sur la base de ce diff√©renciateur, nous pouvons cr√©er une instruction switch sur l'URL de la requ√™te comme suit¬†:

``` js
const requestListener = function (req, res) { 
 res.setHeader("Content-Type", "application/json"); 
 switch (req.url) { 
 case "/items": 
 res.writeHead(200); 
 res.end(items); 
 break 
 case "/manufacturers": 
 res.writeHead(200); 
 res.end(manufacturers); 
 break 
 default: 
 res.writeHead(404); 
 res.end(JSON.stringify({error:"Resource not found"})); 
 } 
}
```

Semblable √† ce que nous avons fait pr√©c√©demment, nous d√©finissons un code de r√©ponse sur 200, pour indiquer un appel r√©ussi, et nous renvoyons le Json dans ce cas. Le cas par d√©faut peut √™tre utilis√© pour signifier une erreur pour le m√™me. Ici, 404, qui signifie ressource non trouv√©e, a plus de sens. 

Si nous testons cela par rapport √† l'appel d'URL curl, nous pouvons voir diff√©rents retours pour les appels :

![nodejs-6.webp](/assets/images/nodejs-6.webp)

Nous pouvons voir que depuis que nous avons ajout√© une valeur par d√©faut, elle est appel√©e dans le cas o√π aucun chemin n'est donn√©, cela v√©rifie les 3 cas d'itin√©raires que nous avons mentionn√©s.


#### Conclusion

Le framework Node.js peut √™tre utilis√© de mani√®re tr√®s extensible et flexible pour d√©velopper des serveurs Web √† l'aide du module ¬´ http ¬ª int√©gr√©. Nous avons vu ci-dessus comment l'application peut √™tre amen√©e √† √©couter sur un port particulier et √† envoyer une r√©ponse au client chaque fois qu'une requ√™te est faite √† l'application. 

Le principal pouvoir de l'utilisation de Node.js pour cr√©er un serveur Web Node est la flexibilit√© qu'il offre en termes de type de r√©ponses que ce soit HTML, JSON, XML, CSV ou la possibilit√© de routage, etc. Nous avons √©galement vu l'√©volutivit√© d'un serveur Web Node. un simple serveur http et ce qu'il peut faire.

En dehors de cela, nous avons √©galement vu comment cr√©er une API capable d'utiliser les informations fournies dans la requ√™te pour d√©terminer quelles donn√©es doivent √™tre envoy√©es dans le cadre de sa r√©ponse. Gr√¢ce √† ces informations, nous pouvons cr√©er des serveurs Web √©volutifs capables de g√©rer une vari√©t√© de demandes et de r√©ponses √©galement sur diff√©rents points de terminaison, ce qui est essentiel lors de la cr√©ation d'API.


#### Foire aux questions (FAQ)
##### Comment puis-je cr√©er un serveur HTTP¬†?

La plupart des langages fournissent un support de base pour ex√©cuter un simple serveur http, bas√© sur certaines fonctions int√©gr√©es, comme dans Node.js, nous utilisons le module http et configurons l'h√¥te et le port, puis en utilisant la fonction createServer dans le module http, demandons au serveur de √©coutez ce port et cet h√¥te, comme ceci ci-dessous¬†:

``` js
const http = require("http"); 
const host = 'localhost'; 
const port = 8000; 
const requestListener = function (req, res) {}; 
const server = http.createServer(requestListener); 
server.listen(port, host, () => { 
 console.log(`Server is running on http://${host}:${port}`); 
});
```


##### Qu'est-ce qu'un serveur HTTP ?

Un serveur HTTP est un programme ind√©pendant ou inclus dans tout autre composant, qui joue le r√¥le de serveur dans le mod√®le client-serveur en impl√©mentant la partie serveur des protocoles r√©seau HTTP. Un serveur HTTP attend les requ√™tes client entrantes qui sont envoy√©es par des agents utilisateurs tels que les navigateurs, les robots d'exploration Web, etc., et √† chaque requ√™te, il r√©pond en r√©pondant avec les informations demand√©es, y compris l'envoi de la ressource Web demand√©e, des textes, des m√©dias ou avec un Message d'erreur HTTP.


##### Comment d√©marrer un serveur Node.js ?

Prenons l'exemple o√π nous avons cr√©√© un serveur √©coutant localhost sur le port 5000, le processus pour l'ex√©cuter sera : 

Dans le terminal, ex√©cutez `node <filename.js>` puis acc√©dez √† <http://localhost:5000> ou vous pouvez √©galement utiliser `curl http://localhost:5000` pour v√©rifier la r√©ponse.


##### Node.js est-il asynchrone¬†?

Oui, Node.js est un environnement d'ex√©cution JavaScript asynchrone bas√© sur des √©v√©nements, con√ßu pour cr√©er des applications r√©seau √©volutives. Ici, asynchrone fait r√©f√©rence √† toutes les fonctions JavaScript qui sont trait√©es en arri√®re-plan sans bloquer aucune autre requ√™te.


## Cr√©er un corps de requ√™te HTTP √† l'aide de Node.js en √©tapes simples

üìù Ce post a √©t√© traduit √† partir de l'article [Create HTTP Request Body Using Node.js in Simple Steps](https://www.knowledgehut.com/blog/web-development/creating-http-server-with-node-js "Create HTTP Request Body Using Node.js in Simple Steps"){:target="_blank"}.

Faire des requ√™tes HTTP est l'une des t√¢ches quotidiennes effectu√©es √† l'aide de Node.js. Vous obtiendrez un ensemble massif de biblioth√®ques compos√©es de modules √† des fins diverses. L'un des modules couramment utilis√©s de Node.js est le module HTTP/HTTPS. La plupart des d√©veloppeurs recherchent ce module lors de la migration vers le nouvel environnement, car les requ√™tes HTTP/HTTPS constituent la fonctionnalit√© de base pour que toute application fonctionne correctement.

Si vous ne souhaitez pas utiliser le module HTTP/HTTPS, vous pouvez utiliser l'un des packages `npm` disponibles pour r√©soudre votre objectif de cr√©ation d'une requ√™te HTTP. Dans cet article, nous mettrons en √©vidence les √©tapes simples pour effectuer une requ√™te HTTP √† l'aide du module HTTP sur le serveur web Node. Ce module est un module int√©gr√© avec l'installation de Node.js et les packages `npm`, tels que `Axios`, `Got SuperAgent` et `node-fetch`.

#### Conditions pr√©alables

Vous ne pouvez pas simplement commencer √† travailler avec Node.js avec une configuration d'environnement de travail appropri√©e. Vous devez remplir certaines conditions pr√©alables avant de vous lancer dans la partie codage. Voyons donc quelles conditions vous devez maintenir pour commencer √† coder avec Node.js.

- Tout d‚Äôabord, avant de commencer √† coder, v√©rifiez si la derni√®re version de Node.js est install√©e sur votre syst√®me. Si vous n'en avez pas, installez la version la plus r√©cente. De plus, dans cet article, nous utiliserons des exemples ex√©cut√©s dans Node.js version 14.x, le LTS actif.
- De plus, vous devez savoir comment ex√©cuter des commandes npm dans node.js, telles que npm init. Assurez-vous d'installer les packages requis au pr√©alable pour √©viter les inconv√©nients lors de l'ex√©cution du code r√©el.
- Vous devez savoir comment ex√©cuter des fichiers JavaScript avec les commandes appropri√©es.
- Vous devez avoir une compr√©hension de base de Node.js, car vous devez g√©rer des √©l√©ments techniques ici.

#### Obtenir une requ√™te HTTP(S)

Le module HTTP est le module par d√©faut de la biblioth√®que standard de Node.js. Vous pouvez utiliser ce module et commencer √† coder sans installer ni g√©rer les d√©pendances externes. Mais, en l'utilisant, vous serez confront√© √† certains d√©fis car ce n'est pas un module convivial par rapport aux autres.

Nous avons utilis√© quelques exemples de [GitHub](https://github.com/webapps-conception/nodejs-requests){:target="_blank"}, le r√©f√©rentiel open source de tous les codes, pour votre meilleure compr√©hension. Ici, nous effectuons une requ√™te GET √† l'aide de l'option client HTTP en appelant les donn√©es stock√©es √† partir de l'API fictive [JSONPlaceholder](https://raw.githubusercontent.com/webapps-conception/nodejs-requests/refs/heads/master/JSONPlaceholder/users){:target="_blank"}. en r√©ponse √† la demande compl√©t√©e, il enverra les donn√©es des dix utilisateurs ainsi que leurs noms et identifiants. dans cet article, nous avons mentionn√© diff√©rents types d'exemples montrant les appels bas√©s sur les rappels, les promesses et les asynchrones/attentes.

Cinq m√©thodes diff√©rentes sont pr√©sent√©es pour effectuer l'appel HTTP GET vers l'API d'espace r√©serv√©. [Node.js](https://nodejs.org/fr){:target="_blank"} propose un module HTTP int√©gr√© pour effectuer plusieurs t√¢ches li√©es √† HTTP afin de faciliter votre travail.

Avant de poursuivre la discussion, vous devez consid√©rer les points suivants concernant le module HTTP/HTTPS :

- Tout d'abord, les modules HTTP et HTTPS fournissent des fonctionnalit√©s de bas niveau. Une fois la demande faite, vous obtiendrez la r√©ponse requise par morceaux plut√¥t que d‚Äôobtenir tous les r√©sultats. De plus, vous devez analyser manuellement la r√©ponse re√ßue. Cela peut sembler simple pour le format JSON, mais vous devez n√©anmoins d√©ployer des efforts suppl√©mentaires pour analyser la r√©ponse compl√®te.
- Deuxi√®mement, votre module HTTP ne prendra pas en charge les requ√™tes HTTPS par d√©faut. Vous devez donc utiliser le module HTTPS si les requ√™tes HTTPS sont effectu√©es lors de la communication.

Malgr√© les d√©fis ci-dessus, le module HTTP/HTTPS est utile car vous serez sauv√© en √©liminant la fiabilit√© de plusieurs d√©pendances.

#### Module de demande

Le module de requ√™te est une option plus conviviale que le module HTTP pour effectuer des appels HTTPS. M√™me les gens de la communaut√© y r√©fl√©chissent. Mais contrairement au module HTTP, vous devez installer le module de requ√™te en tant que [package npm](https://www.npmjs.com/){:target="_blank"}.

Appuyez sur la commande suivante depuis le terminal pour installer le module de requ√™te √† l'aide de npm :

``` bash
npm install request
```

Mais ce module est obsol√®te apr√®s 2020 car aucune modification n‚Äôy a √©t√© apport√©e : pour plus de d√©tails, consultez le site [package request](https://www.npmjs.com/package/request){:target="_blank"}. Mais pour comprendre les rouages du module HTTP en node.js, il sera suffisant...

Apr√®s avoir install√© le module de requ√™te, ex√©cutez la commande suivante pour v√©rifier la version :

``` bash
npm version request
```

Ce module prend en charge les appels et les redirections HTTPS par d√©faut. Dans l'exemple ci-dessous, le code r√©side dans le corps de la requ√™te du code.

Par exemple :

``` js
const request = require('request');  
//python requests body
request('https://raw.githubusercontent.com/webapps-conception/nodejs-requests/refs/heads/master/JSONPlaceholder/users', { json: true }, (err, res, body) => { if (err) {  
return console.log(err); }  
console.log(body.url);  
console.log(body.explanation);  
});
```

##### Poster le corps de la demande avec `curl`. 

Si vous souhaitez publier les donn√©es dans le corps du message de demande √† l'aide de `curl`, vous devez transmettre les donn√©es requises √† Curl. En utilisant le commutateur de ligne de commande -d ou ‚Äìdata, vous pouvez le faire. √Ä l'aide de l'en-t√™te Content-Type, vous pouvez sp√©cifier le type de donn√©es du message que vous souhaitez inclure. Le serveur HTTP Node utilise cet en-t√™te pour interpr√©ter et traiter les donn√©es dans le corps du message POST.

Par exemple, pour envoyer le JSON au serveur Web Node.js, vous devez sp√©cifier le type de donn√©es dans le corps √† l'aide de l'en-t√™te Content-Type: application/json.

Par exemple :

``` bash
//curl post body
curl -X POST https://reqbin.com/echo/post/json  
   -H "Content-Type: application/json"
   -d '{"productId": 123456, "quantity": 100}'  
 Output-
{
    "success": "true"
}
```


#### HTTPS module

Node.js propose des modules HTTP et HTTPS dans sa biblioth√®que standard pour effectuer des appels API HTTP/HTTPS. Pour commencer √† transf√©rer les donn√©es via HTTPS, vous devez inclure le module HTTPS. Ce module cr√©era en outre le serveur Node HTTPS qui √©coutera les ports du serveur pour g√©n√©rer la r√©ponse √† leurs clients.

``` js
const https = require(‚Äòhttps‚Äô);
```

Eh bien, on sait que les requ√™tes HTTPS sont s√©curis√©es. Il serait donc utile de cr√©er √©galement des certificats SSL (auto-sign√©s), garantissant une communication s√©curis√©e. Ici, nous sautons cette partie.

Ici, nous utilisons l'exemple fondamental montrant l'utilisation du module HTTPS pour effectuer l'appel GET.

Par exemple :

``` js
const https = require('https');
https.get('https://raw.githubusercontent.com/webapps-conception/nodejs-requests/refs/heads/master/JSONPlaceholder/users', res => {
let data = [];
  const headerDate = res.headers && res.headers.date ? res.headers.date : 'no response date';
  console.log('Status Code:', res.statusCode);
  console.log('Date in Response header:', headerDate);
 res.on('data', chunk => {
    data.push(chunk);
  });
 res.on('end', () => {
    console.log('Response ended: ');
    const users = JSON.parse(Buffer.concat(data).toString());
  for(user of users) {
      console.log(`Got user with id: ${user.id}, name: ${user.name}`);
    }
  });
}).on('error', err => {
  console.log('Error: ', err.message);
});
```

R√©sultat :
``` bash
-> nodejs-requests git:(master) node native-https.js
Status Code: 200
Date in Response header: Sun, 10 Jan 2021 22:47:23 GMT
Response ended:
Got user with id: 1, name: Leanne Graham
Got user with id: 2, name: Ervin Howell
Got user with id: 3, name: Clementine Bauch
Got user with id: 4, name: Patricia Lebsack
Got user with id: 5, name: Chelsey Dietrich
Got user with id: 6, name: Mrs. Dennis Schulist
Got user with id: 7, name: Kurtis Weissnat
Got user with id: 8, name: Nicholas Runolfsdottir V
Got user with id: 9, name: Glenna Reichert
Got user with id: 10, name: Clementina DuBuque
-> nodejs-requests git:(master)
```

Nous verrons √©tape par √©tape ce qui se passe dans le code ci-dessus. Dans un premier temps, nous avons import√© le module HTTPS en utilisant la fonction requise. Vous obtiendrez ce module avec l'installation de Node.js, il n'est donc pas n√©cessaire de cr√©er un fichier json ou d'installer quoi que ce soit pour ex√©cuter ce code.

Ensuite, nous avons appel√© l'URL `JSONPlaceholder` √† l'aide de la m√©thode get. La m√©thode GET a un rappel qui r√©pondra √† la variable res.

Ensuite, nous initialisons les donn√©es sous forme de tableau vide, puis utilisons le journal pour afficher le code d'√©tat et la date de l'en-t√™te de la r√©ponse. Apr√®s avoir re√ßu la r√©ponse, les donn√©es seront stock√©es dans le tableau de donn√©es.

Ensuite, nous avons utilis√© la fonction concat pour concat√©ner les donn√©es du tableau et les changer en cha√Æne. Ensuite, nous avons analys√© le JSON pour obtenir le nom d'utilisateur et l'ID des 10 utilisateurs.


#### Axios Module

Axios est une autre biblioth√®que Node.Js JavaScript populaire bas√©e sur des promesses. Vous pouvez utiliser ce module sur tous les navigateurs modernes et son formidable support pour IE8 et sup√©rieur. Il est √©galement utilis√© pour effectuer des requ√™tes HTTP qui peuvent fonctionner de mani√®re transparente sur les plates-formes Browser et Node.js.

L'utilisation d'Axios peut √™tre plus avantageuse par rapport √† l'API Fetch native¬†:

- Il prend en charge les anciens navigateurs.
- Il peut rapidement abandonner une demande.
- Il peut d√©finir un d√©lai de r√©ponse.
- Il est livr√© avec une protection CSRF int√©gr√©e.
- Il prend √©galement en charge la progression du t√©l√©chargement.
- Il effectue une transformation automatique des donn√©es JSON.

Pour utiliser le module Axios dans votre code, vous devez l'installer √† l'aide de la commande suivante depuis le terminal.

``` bash
npm install --save axios
```

Dans l'exemple mentionn√© ci-dessous, nous appelons l'API JSON des utilisateurs utilisant Axios.

``` js
const axios = require('axios');
//Axios get body
axios.get('https://raw.githubusercontent.com/webapps-conception/nodejs-requests/refs/heads/master/JSONPlaceholder/users')
.then(res => {
    const headerDate = res.headers && res.headers.date ? res.headers.date : 'no response date';
    console.log('Status Code:', res.status);
    console.log('Date in Response header:', headerDate);
 const users = res.data;
for(user of users) {
      console.log(`Got user with id: ${user.id}, name: ${user.name}`);
    }
  })
  .catch(err => {
    console.log('Error: ', err.message);
  });
```

En raison de sa nature bas√©e sur des promesses, il n√©cessitera un code moins √©vident. En outre, vous pouvez transformer ce code au format async/wait chaque fois que n√©cessaire. Pour utiliser le corps axios, vous devez l'importer √† l'aide de la fonction requise. Ensuite, nous avons utilis√© axios.get (m√©thode bas√©e sur la promesse) pour appeler l'API des utilisateurs JSONPlaceholder.

Ensuite, √† l'aide de la m√©thode ¬´ then ¬ª, nous avons re√ßu les donn√©es demand√©es et avons utilis√© la variable res pour obtenir l'objet de r√©ponse. Ensuite, √† l‚Äôaide de la fonction de journalisation, nous avons affich√© le code d‚Äô√©tat et la date de l‚Äôen-t√™te de r√©ponse.

Les donn√©es JSON seront re√ßues sous forme de tableau avec res. donn√©es en raison de la fonctionnalit√© de transformations automatiques. De plus, nous effectuons la boucle √† travers les utilisateurs pour obtenir leur identifiant et leur nom.

L'exemple ci-dessus concerne Axios get. Maintenant, nous allons voir l'exemple de la publication Axios. Avec Axios, vous pouvez effectuer des demandes de publication en utilisant les donn√©es ¬´¬†post¬†¬ª sur un point de terminaison donn√© qui d√©clencheront les √©v√©nements souhait√©s. Pour effectuer une requ√™te HTTP POST dans Axios, vous devez appeler la fonction axios.post(). Lorsque vous effectuez une requ√™te POST, vous devez utiliser deux param√®tres¬†: l'URI du point de terminaison du service et un objet contenant les propri√©t√©s que vous souhaitez envoyer au serveur HTTP Node.

Par exemple :

``` js
// Axios post body‚ÄìPOST request
axios({
  method: 'post',
  url: '/login',
  data: {
    firstName: 'Finn',
    lastName: 'Williams'
  }
});
```

#### Got Module

Node.js propose une autre biblioth√®que de requ√™tes HTTP saine et couramment utilis√©e, `Got`. Il a √©t√© introduit comme une alternative l√©g√®re au module Request mentionn√© ci-dessus (maintenant obsol√®te). Par d√©faut, `Got` n'analysera pas le JSON. C'est pourquoi nous avons ajout√© le `{json¬†: true}` comme argument dans le code ci-dessous pour inclure l'analyse JSON.

Comme Axios, `Got` est √©galement une API bas√©e sur des promesses, ce qui la rend plus populaire parmi les d√©veloppeurs Node.js.

Pour utiliser le module Got, vous devez l'importer en utilisant la fonction requise ci-dessous.

``` bash
npm install --save got
In the below example, we have used the Got module to get the users from the mock API.
const got = require('got');
got.get('https://raw.githubusercontent.com/webapps-conception/nodejs-requests/refs/heads/master/JSONPlaceholder/users', {responseType: 'json'})
  .then(res => {
    const headerDate = res.headers && res.headers.date ? res.headers.date : 'no response date';
    console.log('Status Code:', res.statusCode);
    console.log('Date in Response header:', headerDate);
   const users = res.body;
    for(user of users) {
      console.log(`Got user with id: ${user.id}, name: ${user.name}`);
    }
  })
  .catch(err => {
    console.log('Error: ', err.message);
  });
```

Si vous regardez attentivement un exemple, vous verrez que le code ci-dessus est en quelque sorte similaire au code Axios mais avec les diff√©rences mentionn√©es ci-dessous.

- Pour sp√©cifier la r√©ponse au format JSON, vous devez transmettre explicitement un deuxi√®me param√®tre¬†: {responseType¬†: 'json'}.
- En outre, il existe une diff√©rence dans l‚Äôen-t√™te du code d‚Äô√©tat, qui est mentionn√© comme statut.

#### SuperAgent Module

SuperAgent est l'un des modules les plus anciens et les plus populaires de Node.js introduit par VisionMedia en 2011. SuperAgent est bien connu comme une biblioth√®que de requ√™tes HTTP progressive c√¥t√© client. Vous pouvez utiliser ce module pour prendre en charge les fonctionnalit√©s client HTTP de haut niveau. Vous pouvez l'utiliser √† la fois pour les API de rappel et celles bas√©es sur des promesses. Ce module est riche en plugins qui peuvent aider √† des t√¢ches telles que le no-cache, les timings HTTP, etc.

√Ä l'aide du module SuperAgent, vous devez l'importer √† l'aide de la commande suivante :

``` bash
npm install --save superagent
```

Dans l'exemple suivant, nous utiliserons async/await pour effectuer l'appel API :

``` js
const superagent = require('superagent');
(async () => {
  try {
    const res = await superagent.get('https://raw.githubusercontent.com/webapps-conception/nodejs-requests/refs/heads/master/JSONPlaceholder/users');
    const headerDate = res.headers && res.headers.date ? res.headers.date : 'no response date';
    console.log('Status Code:', res.statusCode);
    console.log('Date in Response header:', headerDate);
 const users = res.body;
    for(user of users) {
      console.log(`Got user with id: ${user.id}, name: ${user.name}`);
    }
  } catch (err) {
    console.log(err.message); //can be console.error
  }
})();
```

Voyons ce qui se passe dans l'exemple ci-dessus.

Tout d‚Äôabord, nous avons utilis√© la biblioth√®que superagent en utilisant la fonction requise. Ensuite, nous avons utilis√© l'IIFE avec async tout en utilisant l'attente.

Ensuite, nous avons ajout√© le bloc try et appel√© le superagent. get avec wait, dont le but est de r√©soudre la promesse et de g√©n√©rer la r√©ponse des appels HTTP. Ensuite, en utilisant la variable res, nous avons obtenu la date de res.headers. Gr√¢ce √† la fonction de journal, nous affichons l'√©tat et la date sur la console.

Ensuite, nous avons utilis√© la constante ¬´ user ¬ª pour stocker la r√©ponse g√©n√©r√©e et avons parcouru ce tableau de 10 utilisateurs pour obtenir leur nom d'utilisateur et leur identifiant. Ensuite, le bloc catch suivant v√©rifiera les erreurs survenues et les g√©rera en affichant le message d'erreur sur la console.

Vous pouvez dire que le module `SuperAgent` est fiable car il est minutieusement test√© √† l'aide de SuperTest (biblioth√®que Node.js).

#### Node-fetch

Node-fetch est une autre biblioth√®que de requ√™tes HTTP pour Node.js. En raison de la r√©cup√©ration de n≈ìud, vous n'avez pas besoin d'impl√©menter XMLHttpRequest dans Node.js pour ex√©cuter Fetch polyfill sp√©cifique au navigateur. Vous pouvez consid√©rer node.fetch comme un code minimal pour l'API compatible window.fetch sur le runtime Node.js.

Pour utiliser le node.fetch dans votre code, vous devez l'importer √† l'aide du code suivant :

``` js
npm install node-fetch
We will call our mock users API using the node in the code below.fetch module.
const fetch = require('node-fetch');
(async () => {
  try {
    const res = await fetch('https://raw.githubusercontent.com/webapps-conception/nodejs-requests/refs/heads/master/JSONPlaceholder/users');
    const headerDate = res.headers && res.headers.get('date') ? res.headers.get('date') : 'no response date';
    console.log('Status Code:', res.status);
    console.log('Date in Response header:', headerDate);
 const users = await res.json();
    for(user of users) {
      console.log(`Got user with id: ${user.id}, name: ${user.name}`);
    }
  } catch (err) {
    console.log(err.message); //can be console.error
  }
})();
```

Voyons en quoi le code ci-dessus est diff√©rent du code avec SuperAgent utilisant wait/async.

- Avec fetch, vous n'aurez pas besoin d'une m√©thode GET explicite et vous pourrez ajouter la cl√© de m√©thode dans le deuxi√®me param√®tre pour envoyer le verbe HTTP.
- Nous avons √©galement utilis√© la m√©thode get pour obtenir les valeurs d‚Äôen-t√™te. Nous avons appel√© res.headers.get('date') pour r√©cup√©rer la valeur de l'en-t√™te de r√©ponse date.
- Nous avons utilis√© wait res.json() pour d√©baller une promesse d'obtenir le corps au format JSON.

#### HTTP Delete Request

Vous pouvez utiliser le corps de suppression HTTP pour supprimer les ressources sp√©cifiques. Vous trouverez ci-dessous l'exemple de nodejs de corps de requ√™te de suppression http qui supprimera les appels d'API de requ√™te. Voyons le processus complet.

- Cr√©er une application Node.js¬†:
``` bash
mkdir my-request-app
cd my-request-app
npm init
```

- Installez Axios¬†:
``` bash
npm install axios --save
server.js
const axios = require('axios');
 axios.delete('https://reqres.in/api/users/2')
   .then((res) => {
       console.log(`Status: ${res.status}`);
   }).catch((err) => {
       console.error(err);
   });
```

- Ex√©cuter l'application :
``` bash
node server.js
```

- R√©sultat : Statut : 201

#### Conclusion

Nous avons utilis√© des exemples de base pour expliquer le concept. Mais ce n‚Äôest pas tout, car sa port√©e est vaste et ne s‚Äôarr√™te pas l√†. Avec cet article, vous comprendrez comment effectuer la requ√™te HTTP diff√©remment. Node.js dispose d'une biblioth√®que compl√®te avec diff√©rentes fonctions et modules pour rendre chacune de vos √©tapes et processus plus accessibles.

Donc, si vous avez parcouru cet article, vous devez comprendre √† quel point chaque m√©thode est l√©g√®rement diff√©rente des autres. Il n‚Äôest donc peut-√™tre pas difficile de s‚Äôentendre, m√™me pour les d√©butants.

#### Foire aux questions (FAQ)
##### Qu‚Äôest-ce qu‚Äôun corps de requ√™te dans Node.js ?

Le corps de la requ√™te stocke les informations suppl√©mentaires que vous souhaitez envoyer au serveur. Le corps est essentiel car il pr√©cise le contenu que l'on souhaite transmettre. Vous pouvez utiliser le corps de la demande pour stocker des informations utiles, telles que le nom d'utilisateur et le mot de passe d'une personne essayant de se connecter √† notre syst√®me.

##### Comment fonctionnent les requ√™tes HTTP dans Node.js ?

Tout d‚Äôabord, le client √©tablit la connexion via une requ√™te GET. En retour, le serveur r√©pond avec un code d'√©tat. Si le code d'√©tat est 200, le serveur est pr√™t pour une connexion, appel√©e r√©ponse HTTP.

Ensuite, le client envoie la requ√™te (POST) compos√©e des informations de connexion. Le serveur traite les informations apr√®s les avoir v√©rifi√©es par rapport √† la base de donn√©es. Si le serveur correspond √† celui trouv√©, il l'autorisera et renverra la r√©ponse au client.

##### Comment puis-je faire une requ√™te HTTP¬†?

- GET
- POST
- HEAD
- PUT
- DELETE
- CONNECT
- OPTIONS
- TRACE

##### Quelles sont les cinq fa√ßons de cr√©er un corps de requ√™te dans Node.js¬†?

- AXIOS
- Node.fetch
- SuperAgent
- GOT


## Autres projets int√©ressants

- Compilez un seul ex√©cutable √† partir de votre application Node avec Node.js 20 et ESBuild : [webapps-conception/nodejs-server-compilation](https://github.com/webapps-conception/nodejs-server-compilation){:target="_blank"}.

- Pour envoyer un mail avec Node.js : [webapps-conception/nodemailer](https://github.com/webapps-conception/nodemailer){:target="_blank"}.

- [tRPC](https://trpc.io/){:target="_blank"} garantit la s√©curisation du typage de donn√©es dans le contexte d'une stack enti√®rement √©crite en Typescript. Avec tRPC, le code source du client importe directement des √©l√©ments provenant du code source du serveur pour d√©terminer les nommages et le typage des proc√©dures en question. Voici un exemple d'utilisation client-serveur : [webapps-conception/tRPC-example](https://github.com/webapps-conception/tRPC-example){:target="_blank"}.

- Test d'acc√®s √† des donn√©es sur la plateforme [Redis](https://redis.io/fr/){:target="_blank"} : [upstash-redis-node](https://github.com/webapps-conception/upstash-redis-node){:target="_blank"}.

- [graphql-node-server-basic @apollo/server](https://github.com/webapps-conception/graphql-node-server-basic){:target="_blank"}.

